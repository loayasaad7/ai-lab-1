import random

# ======================
# Problem Parameters
# ======================
# Provided list of item sizes (120 items)
items = [
    42, 69, 67, 57, 93, 90, 38, 36, 45, 42, 33, 79, 27, 57, 44, 84, 86, 92, 46, 38,
    85, 33, 82, 73, 49, 70, 59, 23, 57, 72, 74, 69, 33, 42, 28, 46, 30, 64, 29, 74,
    41, 49, 55, 98, 80, 32, 25, 38, 82, 30, 35, 39, 57, 84, 62, 50, 55, 27, 30, 36,
    20, 78, 47, 26, 45, 41, 58, 98, 91, 96, 73, 84, 37, 93, 91, 43, 73, 85, 81, 79,
    71, 80, 76, 83, 41, 78, 70, 23, 42, 87, 43, 84, 60, 55, 49, 78, 73, 62, 36, 44,
    94, 69, 32, 96, 70, 84, 58, 78, 25, 80, 58, 66, 83, 24, 98, 60, 42, 43, 43, 39
]
BIN_CAPACITY = 150       # Maximum capacity of each bin

# ======================
# GA Parameters
# ======================
POP_SIZE = 250            # Number of solutions in the population
NUM_GENERATIONS = 100    # Number of generations to run the algorithm
CROSSOVER_RATE = 1     # Probability of applying crossover
MUTATION_RATE = 0.2      # Probability of applying mutation
TOURNAMENT_SIZE = 5      # Number of individuals in tournament selection
ELITE_SIZE = 50           # Number of best individuals to carry over unchanged

# ======================
# Helper Functions
# ======================

def decode(chromosome, items, bin_capacity):
    """
    Given a chromosome (a permutation of item indices), decode it into bins using a greedy first-fit approach.
    
    Args:
        chromosome (list): Order in which to consider items.
        items (list): List of item sizes.
        bin_capacity (int): Maximum capacity for each bin.
    
    Returns:
        bins (list of lists): Each sublist contains indices of items placed in that bin.
        bin_loads (list): The total load (sum of item sizes) for each bin.
    """
    bins = []
    bin_loads = []
    for index in chromosome:
        item_size = items[index]
        placed = False
        # Try to fit the item into an existing bin
        for i in range(len(bins)):
            if bin_loads[i] + item_size <= bin_capacity:
                bins[i].append(index)
                bin_loads[i] += item_size
                placed = True
                break
        # If the item does not fit in any bin, open a new bin
        if not placed:
            bins.append([index])
            bin_loads.append(item_size)
    return bins, bin_loads

def fitness(chromosome, items, bin_capacity):
    """
    Evaluate the fitness of a chromosome. Since the goal is to minimize the number of bins used,
    the fitness is defined as the inverse of the number of bins. A higher value is better.
    
    Args:
        chromosome (list): Chromosome representing an item order.
        items (list): List of item sizes.
        bin_capacity (int): Maximum capacity for each bin.
    
    Returns:
        float: Fitness value.
    """
    bins, _ = decode(chromosome, items, bin_capacity)
    num_bins = len(bins)
    return 1.0 / num_bins

def tournament_selection(population, items, bin_capacity, tournament_size=TOURNAMENT_SIZE):
    """
    Select one chromosome from the population using tournament selection.
    
    Args:
        population (list): List of chromosomes.
        items (list): List of item sizes.
        bin_capacity (int): Maximum bin capacity.
        tournament_size (int): Number of individuals to compete.
    
    Returns:
        list: The selected chromosome.
    """
    participants = random.sample(population, tournament_size)
    # Choose the participant with the highest fitness
    best = max(participants, key=lambda chrom: fitness(chrom, items, bin_capacity))
    return best

def order_crossover(parent1, parent2):
    """
    Order Crossover (OX) operator for permutations.
    
    The operator selects a random slice from the first parent and preserves the relative order
    of the remaining genes from the second parent.
    
    Args:
        parent1 (list): First parent chromosome.
        parent2 (list): Second parent chromosome.
    
    Returns:
        list: The child chromosome generated by the crossover.
    """
    size = len(parent1)
    child = [None] * size
    # Randomly determine crossover points
    start, end = sorted(random.sample(range(size), 2))
    # Copy the slice from parent1 to child
    child[start:end+1] = parent1[start:end+1]
    # Fill the remaining positions with genes from parent2 in order,
    # skipping those already in the child.
    pointer = 0
    for gene in parent2:
        if gene not in child:
            # Find the next empty spot in child
            while child[pointer] is not None:
                pointer += 1
            child[pointer] = gene
    return child

def swap_mutation(chromosome):
    """
    Swap mutation operator for permutation representation.
    
    Two positions in the chromosome are chosen randomly, and their values are swapped.
    
    Args:
        chromosome (list): Chromosome to be mutated.
    
    Returns:
        list: The mutated chromosome.
    """
    a, b = random.sample(range(len(chromosome)), 2)
    chromosome[a], chromosome[b] = chromosome[b], chromosome[a]
    return chromosome

# ======================
# Genetic Algorithm with Elitism
# ======================

def genetic_algorithm(items, bin_capacity, pop_size, generations, crossover_rate, mutation_rate, elite_size):
    """
    Run the genetic algorithm to optimize the bin packing problem using elitism.
    
    Args:
        items (list): List of item sizes.
        bin_capacity (int): Maximum capacity of each bin.
        pop_size (int): Population size.
        generations (int): Number of generations to iterate.
        crossover_rate (float): Crossover probability.
        mutation_rate (float): Mutation probability.
        elite_size (int): Number of top individuals to carry over unchanged.
    
    Returns:
        tuple: Best solution (chromosome) found and its fitness.
    """
    # Initialize population: each chromosome is a random permutation of item indices
    population = [random.sample(range(len(items)), len(items)) for _ in range(pop_size)]
    best_solution = None
    best_fitness_value = 0

    for g in range(generations):
        new_population = []
        # Evaluate fitness for every chromosome in the population
        pop_fitness = [fitness(chrom, items, bin_capacity) for chrom in population]
        avg_fit = sum(pop_fitness) / len(population)
        best_idx = pop_fitness.index(max(pop_fitness))
        gen_best_fitness = pop_fitness[best_idx]
        
        # Decode best chromosome to get the number of bins used
        best_bins, _ = decode(population[best_idx], items, bin_capacity)
        best_bins_used = len(best_bins)
        
        # Record the best solution seen so far
        if gen_best_fitness > best_fitness_value:
            best_solution = population[best_idx].copy()
            best_fitness_value = gen_best_fitness
        
        # Log statistics for this generation
        print(f"Generation {g}: Best Fitness = {gen_best_fitness:.4f}, Avg Fitness = {avg_fit:.4f}, Best Bins Used = {best_bins_used}")
        
        # Elitism: sort the population and retain the top elite_size individuals
        sorted_population = sorted(population, key=lambda chrom: fitness(chrom, items, bin_capacity), reverse=True)
        elites = sorted_population[:elite_size]
        
        # Add elites to the new population
        new_population.extend(elites)
        
        # Create the remaining individuals in the new generation
        while len(new_population) < pop_size:
            # Parent selection via tournament selection
            parent1 = tournament_selection(population, items, bin_capacity)
            parent2 = tournament_selection(population, items, bin_capacity)
            child = parent1.copy()
            
            # Apply crossover with a given probability
            if random.random() < crossover_rate:
                child = order_crossover(parent1, parent2)
            # Apply mutation with a given probability
            if random.random() < mutation_rate:
                child = swap_mutation(child)
            new_population.append(child)
        
        population = new_population

    return best_solution, best_fitness_value

# ======================
# Main Execution
# ======================


    
# Print the provided items
print("Item sizes:")
print(items)

# Run the genetic algorithm with elitism
best_solution, best_fit = genetic_algorithm(items, BIN_CAPACITY, POP_SIZE, NUM_GENERATIONS,
                                                CROSSOVER_RATE, MUTATION_RATE, ELITE_SIZE)

# Decode the best solution into bin assignments
bins, bin_loads = decode(best_solution, items, BIN_CAPACITY)

# Display the final solution
print("\nBest solution bin assignment:")
for i, (bin_items, load) in enumerate(zip(bins, bin_loads)):
    # Get the sizes of items in the bin for better readability
    bin_item_sizes = [items[idx] for idx in bin_items]
    print(f"Bin {i+1} (load: {load}/{BIN_CAPACITY}): {bin_item_sizes}")
print(f"\nTotal bins used:Â {len(bins)}")